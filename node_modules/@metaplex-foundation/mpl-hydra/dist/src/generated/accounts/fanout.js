"use strict";
/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/metaplex-foundation/kinobi
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.safeFetchFanoutFromSeeds = exports.fetchFanoutFromSeeds = exports.findFanoutPda = exports.getFanoutSize = exports.getFanoutGpaBuilder = exports.safeFetchAllFanout = exports.fetchAllFanout = exports.safeFetchFanout = exports.fetchFanout = exports.deserializeFanout = exports.getFanoutAccountDataSerializer = void 0;
const umi_1 = require("@metaplex-foundation/umi");
const serializers_1 = require("@metaplex-foundation/umi/serializers");
const types_1 = require("../types");
function getFanoutAccountDataSerializer(_context = {}) {
    return (0, serializers_1.mapSerializer)((0, serializers_1.struct)([
        ['discriminator', (0, serializers_1.array)((0, serializers_1.u8)(), { size: 8 })],
        ['authority', (0, serializers_1.publicKey)()],
        ['name', (0, serializers_1.string)()],
        ['accountKey', (0, serializers_1.publicKey)()],
        ['totalShares', (0, serializers_1.u64)()],
        ['totalMembers', (0, serializers_1.u64)()],
        ['totalInflow', (0, serializers_1.u64)()],
        ['lastSnapshotAmount', (0, serializers_1.u64)()],
        ['bumpSeed', (0, serializers_1.u8)()],
        ['accountOwnerBumpSeed', (0, serializers_1.u8)()],
        ['totalAvailableShares', (0, serializers_1.u64)()],
        ['membershipModel', (0, types_1.getMembershipModelSerializer)()],
        ['membershipMint', (0, serializers_1.option)((0, serializers_1.publicKey)())],
        ['totalStakedShares', (0, serializers_1.option)((0, serializers_1.u64)())],
    ], { description: 'FanoutAccountData' }), (value) => ({
        ...value,
        discriminator: [164, 101, 210, 92, 222, 14, 75, 156],
    }));
}
exports.getFanoutAccountDataSerializer = getFanoutAccountDataSerializer;
function deserializeFanout(context, rawAccount) {
    return (0, umi_1.deserializeAccount)(rawAccount ?? context, getFanoutAccountDataSerializer());
}
exports.deserializeFanout = deserializeFanout;
async function fetchFanout(context, publicKey, options) {
    const maybeAccount = await context.rpc.getAccount((0, umi_1.publicKey)(publicKey, false), options);
    (0, umi_1.assertAccountExists)(maybeAccount, 'Fanout');
    return deserializeFanout(maybeAccount);
}
exports.fetchFanout = fetchFanout;
async function safeFetchFanout(context, publicKey, options) {
    const maybeAccount = await context.rpc.getAccount((0, umi_1.publicKey)(publicKey, false), options);
    return maybeAccount.exists ? deserializeFanout(maybeAccount) : null;
}
exports.safeFetchFanout = safeFetchFanout;
async function fetchAllFanout(context, publicKeys, options) {
    const maybeAccounts = await context.rpc.getAccounts(publicKeys.map((key) => (0, umi_1.publicKey)(key, false)), options);
    return maybeAccounts.map((maybeAccount) => {
        (0, umi_1.assertAccountExists)(maybeAccount, 'Fanout');
        return deserializeFanout(maybeAccount);
    });
}
exports.fetchAllFanout = fetchAllFanout;
async function safeFetchAllFanout(context, publicKeys, options) {
    const maybeAccounts = await context.rpc.getAccounts(publicKeys.map((key) => (0, umi_1.publicKey)(key, false)), options);
    return maybeAccounts
        .filter((maybeAccount) => maybeAccount.exists)
        .map((maybeAccount) => deserializeFanout(maybeAccount));
}
exports.safeFetchAllFanout = safeFetchAllFanout;
function getFanoutGpaBuilder(context) {
    const programId = context.programs.getPublicKey('mplHydra', 'hyDQ4Nz1eYyegS6JfenyKwKzYxRsCWCriYSAjtzP4Vg');
    return (0, umi_1.gpaBuilder)(context, programId)
        .registerFields({
        discriminator: [0, (0, serializers_1.array)((0, serializers_1.u8)(), { size: 8 })],
        authority: [8, (0, serializers_1.publicKey)()],
        name: [40, (0, serializers_1.string)()],
        accountKey: [null, (0, serializers_1.publicKey)()],
        totalShares: [null, (0, serializers_1.u64)()],
        totalMembers: [null, (0, serializers_1.u64)()],
        totalInflow: [null, (0, serializers_1.u64)()],
        lastSnapshotAmount: [null, (0, serializers_1.u64)()],
        bumpSeed: [null, (0, serializers_1.u8)()],
        accountOwnerBumpSeed: [null, (0, serializers_1.u8)()],
        totalAvailableShares: [null, (0, serializers_1.u64)()],
        membershipModel: [null, (0, types_1.getMembershipModelSerializer)()],
        membershipMint: [null, (0, serializers_1.option)((0, serializers_1.publicKey)())],
        totalStakedShares: [null, (0, serializers_1.option)((0, serializers_1.u64)())],
    })
        .deserializeUsing((account) => deserializeFanout(account))
        .whereField('discriminator', [164, 101, 210, 92, 222, 14, 75, 156]);
}
exports.getFanoutGpaBuilder = getFanoutGpaBuilder;
function getFanoutSize() {
    return 300;
}
exports.getFanoutSize = getFanoutSize;
function findFanoutPda(context, seeds) {
    const programId = context.programs.getPublicKey('mplHydra', 'hyDQ4Nz1eYyegS6JfenyKwKzYxRsCWCriYSAjtzP4Vg');
    return context.eddsa.findPda(programId, [
        (0, serializers_1.string)({ size: 'variable' }).serialize('fanout-config'),
        (0, serializers_1.string)({ size: 'variable' }).serialize(seeds.name),
    ]);
}
exports.findFanoutPda = findFanoutPda;
async function fetchFanoutFromSeeds(context, seeds, options) {
    return fetchFanout(context, findFanoutPda(context, seeds), options);
}
exports.fetchFanoutFromSeeds = fetchFanoutFromSeeds;
async function safeFetchFanoutFromSeeds(context, seeds, options) {
    return safeFetchFanout(context, findFanoutPda(context, seeds), options);
}
exports.safeFetchFanoutFromSeeds = safeFetchFanoutFromSeeds;
//# sourceMappingURL=fanout.js.map