"use strict";
/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/metaplex-foundation/kinobi
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMplHydraErrorFromName = exports.getMplHydraErrorFromCode = exports.InvalidCloseAccountDestinationError = exports.RemoveSharesMustBeZeroError = exports.RemoveNotSupportedError = exports.TransferNotSupportedError = exports.CannotTransferToSelfError = exports.InvalidStakeAtaError = exports.MustDistributeError = exports.InvalidFanoutForMintError = exports.InsufficientBalanceToDistributeError = exports.NumericalOverflowError = exports.InvalidMetadataError = exports.WalletDoesNotOwnMembershipTokenError = exports.IncorrectOwnerError = exports.DerivedKeyInvalidError = exports.HoldingAccountMustBeAnATAError = exports.InvalidHoldingAccountError = exports.MintDoesNotMatchError = exports.InvalidMembershipVoucherError = exports.InvalidMembershipModelError = exports.MintAccountRequiredError = exports.NewMintAccountRequiredError = exports.SharesArentAtMaxError = exports.InsufficientSharesError = exports.InvalidAuthorityError = exports.BadArtithmeticError = void 0;
const umi_1 = require("@metaplex-foundation/umi");
const codeToErrorMap = new Map();
const nameToErrorMap = new Map();
/** BadArtithmetic: Encountered an arithmetic error */
class BadArtithmeticError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Encountered an arithmetic error', program, cause);
        this.name = 'BadArtithmetic';
        this.code = 0x1770; // 6000
    }
}
exports.BadArtithmeticError = BadArtithmeticError;
codeToErrorMap.set(0x1770, BadArtithmeticError);
nameToErrorMap.set('BadArtithmetic', BadArtithmeticError);
/** InvalidAuthority: Invalid authority */
class InvalidAuthorityError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid authority', program, cause);
        this.name = 'InvalidAuthority';
        this.code = 0x1771; // 6001
    }
}
exports.InvalidAuthorityError = InvalidAuthorityError;
codeToErrorMap.set(0x1771, InvalidAuthorityError);
nameToErrorMap.set('InvalidAuthority', InvalidAuthorityError);
/** InsufficientShares: Not Enough Available Shares */
class InsufficientSharesError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Not Enough Available Shares', program, cause);
        this.name = 'InsufficientShares';
        this.code = 0x1772; // 6002
    }
}
exports.InsufficientSharesError = InsufficientSharesError;
codeToErrorMap.set(0x1772, InsufficientSharesError);
nameToErrorMap.set('InsufficientShares', InsufficientSharesError);
/** SharesArentAtMax: All available shares must be assigned to a member */
class SharesArentAtMaxError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('All available shares must be assigned to a member', program, cause);
        this.name = 'SharesArentAtMax';
        this.code = 0x1773; // 6003
    }
}
exports.SharesArentAtMaxError = SharesArentAtMaxError;
codeToErrorMap.set(0x1773, SharesArentAtMaxError);
nameToErrorMap.set('SharesArentAtMax', SharesArentAtMaxError);
/** NewMintAccountRequired: A New mint account must be provided */
class NewMintAccountRequiredError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('A New mint account must be provided', program, cause);
        this.name = 'NewMintAccountRequired';
        this.code = 0x1774; // 6004
    }
}
exports.NewMintAccountRequiredError = NewMintAccountRequiredError;
codeToErrorMap.set(0x1774, NewMintAccountRequiredError);
nameToErrorMap.set('NewMintAccountRequired', NewMintAccountRequiredError);
/** MintAccountRequired: A Token type Fanout requires a Membership Mint */
class MintAccountRequiredError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('A Token type Fanout requires a Membership Mint', program, cause);
        this.name = 'MintAccountRequired';
        this.code = 0x1775; // 6005
    }
}
exports.MintAccountRequiredError = MintAccountRequiredError;
codeToErrorMap.set(0x1775, MintAccountRequiredError);
nameToErrorMap.set('MintAccountRequired', MintAccountRequiredError);
/** InvalidMembershipModel: Invalid Membership Model */
class InvalidMembershipModelError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid Membership Model', program, cause);
        this.name = 'InvalidMembershipModel';
        this.code = 0x1776; // 6006
    }
}
exports.InvalidMembershipModelError = InvalidMembershipModelError;
codeToErrorMap.set(0x1776, InvalidMembershipModelError);
nameToErrorMap.set('InvalidMembershipModel', InvalidMembershipModelError);
/** InvalidMembershipVoucher: Invalid Membership Voucher */
class InvalidMembershipVoucherError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid Membership Voucher', program, cause);
        this.name = 'InvalidMembershipVoucher';
        this.code = 0x1777; // 6007
    }
}
exports.InvalidMembershipVoucherError = InvalidMembershipVoucherError;
codeToErrorMap.set(0x1777, InvalidMembershipVoucherError);
nameToErrorMap.set('InvalidMembershipVoucher', InvalidMembershipVoucherError);
/** MintDoesNotMatch: Invalid Mint for the config */
class MintDoesNotMatchError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid Mint for the config', program, cause);
        this.name = 'MintDoesNotMatch';
        this.code = 0x1778; // 6008
    }
}
exports.MintDoesNotMatchError = MintDoesNotMatchError;
codeToErrorMap.set(0x1778, MintDoesNotMatchError);
nameToErrorMap.set('MintDoesNotMatch', MintDoesNotMatchError);
/** InvalidHoldingAccount: Holding account does not match the config */
class InvalidHoldingAccountError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Holding account does not match the config', program, cause);
        this.name = 'InvalidHoldingAccount';
        this.code = 0x1779; // 6009
    }
}
exports.InvalidHoldingAccountError = InvalidHoldingAccountError;
codeToErrorMap.set(0x1779, InvalidHoldingAccountError);
nameToErrorMap.set('InvalidHoldingAccount', InvalidHoldingAccountError);
/** HoldingAccountMustBeAnATA: A Mint holding account must be an ata for the mint owned by the config */
class HoldingAccountMustBeAnATAError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('A Mint holding account must be an ata for the mint owned by the config', program, cause);
        this.name = 'HoldingAccountMustBeAnATA';
        this.code = 0x177a; // 6010
    }
}
exports.HoldingAccountMustBeAnATAError = HoldingAccountMustBeAnATAError;
codeToErrorMap.set(0x177a, HoldingAccountMustBeAnATAError);
nameToErrorMap.set('HoldingAccountMustBeAnATA', HoldingAccountMustBeAnATAError);
/** DerivedKeyInvalid */
class DerivedKeyInvalidError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'DerivedKeyInvalid';
        this.code = 0x177b; // 6011
    }
}
exports.DerivedKeyInvalidError = DerivedKeyInvalidError;
codeToErrorMap.set(0x177b, DerivedKeyInvalidError);
nameToErrorMap.set('DerivedKeyInvalid', DerivedKeyInvalidError);
/** IncorrectOwner */
class IncorrectOwnerError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'IncorrectOwner';
        this.code = 0x177c; // 6012
    }
}
exports.IncorrectOwnerError = IncorrectOwnerError;
codeToErrorMap.set(0x177c, IncorrectOwnerError);
nameToErrorMap.set('IncorrectOwner', IncorrectOwnerError);
/** WalletDoesNotOwnMembershipToken: Wallet Does not Own Membership Token */
class WalletDoesNotOwnMembershipTokenError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Wallet Does not Own Membership Token', program, cause);
        this.name = 'WalletDoesNotOwnMembershipToken';
        this.code = 0x177d; // 6013
    }
}
exports.WalletDoesNotOwnMembershipTokenError = WalletDoesNotOwnMembershipTokenError;
codeToErrorMap.set(0x177d, WalletDoesNotOwnMembershipTokenError);
nameToErrorMap.set('WalletDoesNotOwnMembershipToken', WalletDoesNotOwnMembershipTokenError);
/** InvalidMetadata: The Metadata specified is not valid Token Metadata */
class InvalidMetadataError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('The Metadata specified is not valid Token Metadata', program, cause);
        this.name = 'InvalidMetadata';
        this.code = 0x177e; // 6014
    }
}
exports.InvalidMetadataError = InvalidMetadataError;
codeToErrorMap.set(0x177e, InvalidMetadataError);
nameToErrorMap.set('InvalidMetadata', InvalidMetadataError);
/** NumericalOverflow */
class NumericalOverflowError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'NumericalOverflow';
        this.code = 0x177f; // 6015
    }
}
exports.NumericalOverflowError = NumericalOverflowError;
codeToErrorMap.set(0x177f, NumericalOverflowError);
nameToErrorMap.set('NumericalOverflow', NumericalOverflowError);
/** InsufficientBalanceToDistribute: Not enough new balance to distribute */
class InsufficientBalanceToDistributeError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Not enough new balance to distribute', program, cause);
        this.name = 'InsufficientBalanceToDistribute';
        this.code = 0x1780; // 6016
    }
}
exports.InsufficientBalanceToDistributeError = InsufficientBalanceToDistributeError;
codeToErrorMap.set(0x1780, InsufficientBalanceToDistributeError);
nameToErrorMap.set('InsufficientBalanceToDistribute', InsufficientBalanceToDistributeError);
/** InvalidFanoutForMint */
class InvalidFanoutForMintError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'InvalidFanoutForMint';
        this.code = 0x1781; // 6017
    }
}
exports.InvalidFanoutForMintError = InvalidFanoutForMintError;
codeToErrorMap.set(0x1781, InvalidFanoutForMintError);
nameToErrorMap.set('InvalidFanoutForMint', InvalidFanoutForMintError);
/** MustDistribute: This operation must be the instruction right after a distrobution on the same accounts. */
class MustDistributeError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('This operation must be the instruction right after a distrobution on the same accounts.', program, cause);
        this.name = 'MustDistribute';
        this.code = 0x1782; // 6018
    }
}
exports.MustDistributeError = MustDistributeError;
codeToErrorMap.set(0x1782, MustDistributeError);
nameToErrorMap.set('MustDistribute', MustDistributeError);
/** InvalidStakeAta */
class InvalidStakeAtaError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'InvalidStakeAta';
        this.code = 0x1783; // 6019
    }
}
exports.InvalidStakeAtaError = InvalidStakeAtaError;
codeToErrorMap.set(0x1783, InvalidStakeAtaError);
nameToErrorMap.set('InvalidStakeAta', InvalidStakeAtaError);
/** CannotTransferToSelf */
class CannotTransferToSelfError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'CannotTransferToSelf';
        this.code = 0x1784; // 6020
    }
}
exports.CannotTransferToSelfError = CannotTransferToSelfError;
codeToErrorMap.set(0x1784, CannotTransferToSelfError);
nameToErrorMap.set('CannotTransferToSelf', CannotTransferToSelfError);
/** TransferNotSupported: Transfer is not supported on this membership model */
class TransferNotSupportedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Transfer is not supported on this membership model', program, cause);
        this.name = 'TransferNotSupported';
        this.code = 0x1785; // 6021
    }
}
exports.TransferNotSupportedError = TransferNotSupportedError;
codeToErrorMap.set(0x1785, TransferNotSupportedError);
nameToErrorMap.set('TransferNotSupported', TransferNotSupportedError);
/** RemoveNotSupported: Remove is not supported on this membership model */
class RemoveNotSupportedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Remove is not supported on this membership model', program, cause);
        this.name = 'RemoveNotSupported';
        this.code = 0x1786; // 6022
    }
}
exports.RemoveNotSupportedError = RemoveNotSupportedError;
codeToErrorMap.set(0x1786, RemoveNotSupportedError);
nameToErrorMap.set('RemoveNotSupported', RemoveNotSupportedError);
/** RemoveSharesMustBeZero: Before you remove a wallet or NFT member please transfer the shares to another member */
class RemoveSharesMustBeZeroError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Before you remove a wallet or NFT member please transfer the shares to another member', program, cause);
        this.name = 'RemoveSharesMustBeZero';
        this.code = 0x1787; // 6023
    }
}
exports.RemoveSharesMustBeZeroError = RemoveSharesMustBeZeroError;
codeToErrorMap.set(0x1787, RemoveSharesMustBeZeroError);
nameToErrorMap.set('RemoveSharesMustBeZero', RemoveSharesMustBeZeroError);
/** InvalidCloseAccountDestination: Sending Sol to a SPL token destination will render the sol unusable */
class InvalidCloseAccountDestinationError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Sending Sol to a SPL token destination will render the sol unusable', program, cause);
        this.name = 'InvalidCloseAccountDestination';
        this.code = 0x1788; // 6024
    }
}
exports.InvalidCloseAccountDestinationError = InvalidCloseAccountDestinationError;
codeToErrorMap.set(0x1788, InvalidCloseAccountDestinationError);
nameToErrorMap.set('InvalidCloseAccountDestination', InvalidCloseAccountDestinationError);
/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 */
function getMplHydraErrorFromCode(code, program, cause) {
    const constructor = codeToErrorMap.get(code);
    return constructor ? new constructor(program, cause) : null;
}
exports.getMplHydraErrorFromCode = getMplHydraErrorFromCode;
/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 */
function getMplHydraErrorFromName(name, program, cause) {
    const constructor = nameToErrorMap.get(name);
    return constructor ? new constructor(program, cause) : null;
}
exports.getMplHydraErrorFromName = getMplHydraErrorFromName;
//# sourceMappingURL=mplHydra.js.map